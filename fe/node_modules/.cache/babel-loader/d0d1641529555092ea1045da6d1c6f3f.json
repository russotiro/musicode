{"ast":null,"code":"/*! (c) Andrea Giammarchi - ISC */\nvar self = this || /* istanbul ignore next */{};\ntry {\n  (function (URLSearchParams, plus) {\n    if (new URLSearchParams('q=%2B').get('q') !== plus || new URLSearchParams({\n      q: plus\n    }).get('q') !== plus || new URLSearchParams([['q', plus]]).get('q') !== plus || new URLSearchParams('q=\\n').toString() !== 'q=%0A' || new URLSearchParams({\n      q: ' &'\n    }).toString() !== 'q=+%26' || new URLSearchParams({\n      q: '%zx'\n    }).toString() !== 'q=%25zx') throw URLSearchParams;\n    self.URLSearchParams = URLSearchParams;\n  })(URLSearchParams, '+');\n} catch (URLSearchParams) {\n  (function (Object, String, isArray) {\n    'use strict';\n\n    var create = Object.create;\n    var defineProperty = Object.defineProperty;\n    var find = /[!'\\(\\)~]|%20|%00/g;\n    var findPercentSign = /%(?![0-9a-fA-F]{2})/g;\n    var plus = /\\+/g;\n    var replace = {\n      '!': '%21',\n      \"'\": '%27',\n      '(': '%28',\n      ')': '%29',\n      '~': '%7E',\n      '%20': '+',\n      '%00': '\\x00'\n    };\n    var proto = {\n      append: function append(key, value) {\n        appendTo(this._ungap, key, value);\n      },\n      delete: function _delete(key) {\n        delete this._ungap[key];\n      },\n      get: function get(key) {\n        return this.has(key) ? this._ungap[key][0] : null;\n      },\n      getAll: function getAll(key) {\n        return this.has(key) ? this._ungap[key].slice(0) : [];\n      },\n      has: function has(key) {\n        return key in this._ungap;\n      },\n      set: function set(key, value) {\n        this._ungap[key] = [String(value)];\n      },\n      forEach: function forEach(callback, thisArg) {\n        var self = this;\n        for (var key in self._ungap) self._ungap[key].forEach(invoke, key);\n        function invoke(value) {\n          callback.call(thisArg, value, String(key), self);\n        }\n      },\n      toJSON: function toJSON() {\n        return {};\n      },\n      toString: function toString() {\n        var query = [];\n        for (var key in this._ungap) {\n          var encoded = encode(key);\n          for (var i = 0, value = this._ungap[key]; i < value.length; i++) {\n            query.push(encoded + '=' + encode(value[i]));\n          }\n        }\n        return query.join('&');\n      }\n    };\n    for (var key in proto) defineProperty(URLSearchParams.prototype, key, {\n      configurable: true,\n      writable: true,\n      value: proto[key]\n    });\n    self.URLSearchParams = URLSearchParams;\n    function URLSearchParams(query) {\n      var dict = create(null);\n      defineProperty(this, '_ungap', {\n        value: dict\n      });\n      switch (true) {\n        case !query:\n          break;\n        case typeof query === 'string':\n          if (query.charAt(0) === '?') {\n            query = query.slice(1);\n          }\n          for (var pairs = query.split('&'), i = 0, length = pairs.length; i < length; i++) {\n            var value = pairs[i];\n            var index = value.indexOf('=');\n            if (-1 < index) {\n              appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));\n            } else if (value.length) {\n              appendTo(dict, decode(value), '');\n            }\n          }\n          break;\n        case isArray(query):\n          for (var i = 0, length = query.length; i < length; i++) {\n            var value = query[i];\n            appendTo(dict, value[0], value[1]);\n          }\n          break;\n        case 'forEach' in query:\n          query.forEach(addEach, dict);\n          break;\n        default:\n          for (var key in query) appendTo(dict, key, query[key]);\n      }\n    }\n    function addEach(value, key) {\n      appendTo(this, key, value);\n    }\n    function appendTo(dict, key, value) {\n      var res = isArray(value) ? value.join(',') : value;\n      if (key in dict) dict[key].push(res);else dict[key] = [res];\n    }\n    function decode(str) {\n      return decodeURIComponent(str.replace(findPercentSign, '%25').replace(plus, ' '));\n    }\n    function encode(str) {\n      return encodeURIComponent(str).replace(find, replacer);\n    }\n    function replacer(match) {\n      return replace[match];\n    }\n  })(Object, String, Array.isArray);\n}\n(function (URLSearchParamsProto) {\n  var iterable = false;\n  try {\n    iterable = !!Symbol.iterator;\n  } catch (o_O) {}\n\n  /* istanbul ignore else */\n  if (!('forEach' in URLSearchParamsProto)) {\n    URLSearchParamsProto.forEach = function forEach(callback, thisArg) {\n      var self = this;\n      var names = Object.create(null);\n      this.toString().replace(/=[\\s\\S]*?(?:&|$)/g, '=').split('=').forEach(function (name) {\n        if (!name.length || name in names) return;\n        (names[name] = self.getAll(name)).forEach(function (value) {\n          callback.call(thisArg, value, name, self);\n        });\n      });\n    };\n  }\n\n  /* istanbul ignore else */\n  if (!('keys' in URLSearchParamsProto)) {\n    URLSearchParamsProto.keys = function keys() {\n      return iterator(this, function (value, key) {\n        this.push(key);\n      });\n    };\n  }\n\n  /* istanbul ignore else */\n  if (!('values' in URLSearchParamsProto)) {\n    URLSearchParamsProto.values = function values() {\n      return iterator(this, function (value, key) {\n        this.push(value);\n      });\n    };\n  }\n\n  /* istanbul ignore else */\n  if (!('entries' in URLSearchParamsProto)) {\n    URLSearchParamsProto.entries = function entries() {\n      return iterator(this, function (value, key) {\n        this.push([key, value]);\n      });\n    };\n  }\n\n  /* istanbul ignore else */\n  if (iterable && !(Symbol.iterator in URLSearchParamsProto)) {\n    URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;\n  }\n\n  /* istanbul ignore else */\n  if (!('sort' in URLSearchParamsProto)) {\n    URLSearchParamsProto.sort = function sort() {\n      var entries = this.entries(),\n        entry = entries.next(),\n        done = entry.done,\n        keys = [],\n        values = Object.create(null),\n        i,\n        key,\n        value;\n      while (!done) {\n        value = entry.value;\n        key = value[0];\n        keys.push(key);\n        if (!(key in values)) {\n          values[key] = [];\n        }\n        values[key].push(value[1]);\n        entry = entries.next();\n        done = entry.done;\n      }\n      // not the champion in efficiency\n      // but these two bits just do the job\n      keys.sort();\n      for (i = 0; i < keys.length; i++) {\n        this.delete(keys[i]);\n      }\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        this.append(key, values[key].shift());\n      }\n    };\n  }\n  function iterator(self, callback) {\n    var items = [];\n    self.forEach(callback, items);\n    return iterable ? items[Symbol.iterator]() : {\n      next: function next() {\n        var value = items.shift();\n        return {\n          done: value === undefined,\n          value: value\n        };\n      }\n    };\n  }\n\n  /* istanbul ignore next */\n  (function (Object) {\n    var dP = Object.defineProperty,\n      gOPD = Object.getOwnPropertyDescriptor,\n      createSearchParamsPollute = function createSearchParamsPollute(search) {\n        function append(name, value) {\n          URLSearchParamsProto.append.call(this, name, value);\n          name = this.toString();\n          search.set.call(this._usp, name ? '?' + name : '');\n        }\n        function del(name) {\n          URLSearchParamsProto.delete.call(this, name);\n          name = this.toString();\n          search.set.call(this._usp, name ? '?' + name : '');\n        }\n        function set(name, value) {\n          URLSearchParamsProto.set.call(this, name, value);\n          name = this.toString();\n          search.set.call(this._usp, name ? '?' + name : '');\n        }\n        return function (sp, value) {\n          sp.append = append;\n          sp.delete = del;\n          sp.set = set;\n          return dP(sp, '_usp', {\n            configurable: true,\n            writable: true,\n            value: value\n          });\n        };\n      },\n      createSearchParamsCreate = function createSearchParamsCreate(polluteSearchParams) {\n        return function (obj, sp) {\n          dP(obj, '_searchParams', {\n            configurable: true,\n            writable: true,\n            value: polluteSearchParams(sp, obj)\n          });\n          return sp;\n        };\n      },\n      updateSearchParams = function updateSearchParams(sp) {\n        var append = sp.append;\n        sp.append = URLSearchParamsProto.append;\n        URLSearchParams.call(sp, sp._usp.search.slice(1));\n        sp.append = append;\n      },\n      verifySearchParams = function verifySearchParams(obj, Class) {\n        if (!(obj instanceof Class)) throw new TypeError(\"'searchParams' accessed on an object that \" + \"does not implement interface \" + Class.name);\n      },\n      upgradeClass = function upgradeClass(Class) {\n        var ClassProto = Class.prototype,\n          searchParams = gOPD(ClassProto, 'searchParams'),\n          href = gOPD(ClassProto, 'href'),\n          search = gOPD(ClassProto, 'search'),\n          createSearchParams;\n        if (!searchParams && search && search.set) {\n          createSearchParams = createSearchParamsCreate(createSearchParamsPollute(search));\n          Object.defineProperties(ClassProto, {\n            href: {\n              get: function get() {\n                return href.get.call(this);\n              },\n              set: function set(value) {\n                var sp = this._searchParams;\n                href.set.call(this, value);\n                if (sp) updateSearchParams(sp);\n              }\n            },\n            search: {\n              get: function get() {\n                return search.get.call(this);\n              },\n              set: function set(value) {\n                var sp = this._searchParams;\n                search.set.call(this, value);\n                if (sp) updateSearchParams(sp);\n              }\n            },\n            searchParams: {\n              get: function get() {\n                verifySearchParams(this, Class);\n                return this._searchParams || createSearchParams(this, new URLSearchParams(this.search.slice(1)));\n              },\n              set: function set(sp) {\n                verifySearchParams(this, Class);\n                createSearchParams(this, sp);\n              }\n            }\n          });\n        }\n      };\n    try {\n      upgradeClass(HTMLAnchorElement);\n      if (/^function|object$/.test(typeof URL) && URL.prototype) upgradeClass(URL);\n    } catch (meh) {}\n  })(Object);\n})(self.URLSearchParams.prototype, Object);\nexport default self.URLSearchParams;","map":null,"metadata":{},"sourceType":"module"}